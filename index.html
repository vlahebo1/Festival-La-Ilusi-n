<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>La Ilusión - Inmersivo</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  canvas { display:block; }
  #overlay {
    position: absolute; top:0; left:0; width:100%; height:100%;
    display:flex; align-items:center; justify-content:center;
    background: rgba(0,0,0,0.85); color:#fff; font-family:sans-serif;
    flex-direction:column; z-index: 10;
  }
 #overlay button {
    padding: 12px 24px;
    font-size: 13pt;
    cursor: pointer;
    margin-top: 16px;
    border: none;
    border-radius: 8px;
    background: #10b981;
    color: #fff;
    font-family: monospace;
    border: white;
    border-inline: white;
    border-style: solid;
}

 h3 {
    font-family: monospace;
    text-align: center;
    font-size: 16pt;
    font-weight: bold;
    max-width: 100%;
    margin-left: auto;
    margin-right: auto;
    margin-top: 100px;
}
h4 {
    font-family: monospace;
    text-align: center;
    font-size: 18pt;
    font-weight: unset;
    max-width: 100%;
    margin-top: 54px;
    margin-left: auto;
    margin-right: auto;

}

h5 {
    font-family: monospace;
    text-align: center;
    font-size: 12pt;
    font-weight: unset;
    max-width: 6¿70%;
    margin-top: -21px;
    margin-left: auto;
    margin-right: auto;

}

  h6 {
    font-family: monospace;
    text-align: center;
    font-size: 10pt;
    font-weight: unset;
    max-width: 70%;
    margin-top: 54px;
    margin-left: auto;
    margin-right: auto;

}

    h2 {
    font-family: monospace;
    text-align: center;
    font-size: 10pt;
    font-weight: unset;
    max-width: 100%;
    margin-top: 10px;
    margin-left: auto;
    margin-right: auto;

}
.texto-intro {
      font-family: monospace;
    max-width: 70%;
    text-align: center;
    font-weight: unset;
    margin-bottom: 34px;
      font-size: 11pt;

}

/* --- Estilos joystick --- */
.joystick {
  position: absolute;
  width: 120px;
  height: 120px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.15);
  border: 2px solid rgba(255,255,255,0.3);
  box-shadow: 0 0 10px rgba(0,0,0,0.5);
  touch-action: none;
  display: flex;
  align-items: center;
  justify-content: center;
}

.joystick-inner {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.4);
  border: 2px solid rgba(255,255,255,0.6);
  box-shadow: 0 0 6px rgba(0,0,0,0.5);
  transform: translate(0,0);
  transition: transform 0.05s;
  pointer-events: none;
}


</style>
</head>
<body>

<div id="forestLossCounter" style="
  position: fixed;
  top: 20px;
  right: 20px;
  background: rgba(0,0,0,0.6);
  color: #fff;
  padding: 10px 16px;
  font-family: monospace;
  font-size: 16px;
  border-radius: 8px;
  z-index: 10000;
"></div>
<div id="overlay">

  

  
  <div><h3><center><strong>Festival La Ilusión | Escuchar el bosque</strong></center></h3></div>
  <div><h5>||| La experiencia inmersiva solo es posible si usas audifonos |||</center></h5></div>
 <div class="texto-intro">Camina por el bosque usando las teclas W, A, S, D y tu mouse. Cada esfera entre los árboles reproduce una obra sonora del Festival La Ilusión. Para salir usa [ESC]<br></center></div>
<div></div>
  <button id="enterBtn">Entrar al bosque</button>

<div><h6>Las obras sonoras incluidas en esta experiencia hacen parte de la selección del Festival La Ilusión, y son propiedad de sus autorxs<br>Las obras de individuales están disponibles en www.lailusionfestival.com</h6></div>
<div><h2>|||| @vlahebo v1.8l</h2></div>

</div>

 <div id="rotateMessage" 
  style="
    display:none;
    position:fixed;
    top:0;
    left:0;
    width:100%;
    height:100%;
    background:black;
    color:white;
    font-size:1.2em;
    justify-content:center;
    align-items:center;
    z-index:9999;
    text-align:center;
  ">
  Por favor gira tu dispositivo a modo horizontal para continuar
</div>

<script>
function checkOrientation() {
  const msg = document.getElementById('rotateMessage');
  const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  const isPortrait = window.matchMedia("(orientation: portrait)").matches;
  
  // Solo mostrar mensaje si está en móvil y en modo vertical
  if (isMobile && isPortrait) {
    msg.style.display = 'flex';
  } else {
    msg.style.display = 'none';
  }
}

window.addEventListener('resize', checkOrientation);
window.addEventListener('orientationchange', checkOrientation);
document.addEventListener('DOMContentLoaded', checkOrientation);
</script>


<script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>

<script>
// --- PointerLockControls ---
class PointerLockControls {
  constructor(camera, domElement) {
    this.camera = camera;
    this.domElement = domElement;
    this.isLocked = false;
    this.euler = new THREE.Euler(0,0,0,'YXZ');
    this.PI_2 = Math.PI/2;
    this.domElement.addEventListener('click', () => this.lock(), false);
    document.addEventListener('pointerlockchange', () => {
      this.isLocked = document.pointerLockElement === this.domElement;
    });
    this.domElement.addEventListener('mousemove', (event) => {
      if (!this.isLocked) return;
      const movementX = event.movementX || 0;
      const movementY = event.movementY || 0;
      this.euler.setFromQuaternion(this.camera.quaternion);
      this.euler.y -= movementX * 0.002;
      this.euler.x -= movementY * 0.002;
      this.euler.x = Math.max(-this.PI_2, Math.min(this.PI_2, this.euler.x));
      this.camera.quaternion.setFromEuler(this.euler);
    }, false);
    this.moveForward = this.moveBackward = this.moveLeft = this.moveRight = false;
    document.addEventListener('keydown', (e) => this.onKey(e,true));
    document.addEventListener('keyup', (e) => this.onKey(e,false));
    this.velocity = new THREE.Vector3();
  }
  lock() { this.domElement.requestPointerLock(); }
  onKey(e, down) {
    switch(e.code){
      case 'KeyW': this.moveForward=down; break;
      case 'KeyS': this.moveBackward=down; break;
      case 'KeyA': this.moveLeft=down; break;
      case 'KeyD': this.moveRight=down; break;
    }
  }
  update(delta) {
    const speed = 5;
    this.velocity.set(0,0,0);
    if(this.moveForward) this.velocity.z -= speed*delta;
    if(this.moveBackward) this.velocity.z += speed*delta;
    if(this.moveLeft) this.velocity.x -= speed*delta;
    if(this.moveRight) this.velocity.x += speed*delta;
    const direction = new THREE.Vector3();
    direction.copy(this.velocity).applyQuaternion(this.camera.quaternion);
    this.camera.position.add(direction);
  }
}

// --- Escena base ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 3000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);
const forestLossDiv = document.getElementById('forestLossCounter');
const lossRate = 54; // m² por segundo
let elapsedTime = 0; // segundos
camera.position.set(0, 1.6, 0);
camera.lookAt(new THREE.Vector3(0, 1.6, -1));


// --- Luz ambiental ---
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dirLight = new THREE.DirectionalLight(0xffffff,0.8);
dirLight.position.set(10,20,10);
scene.add(dirLight);

  // --- Arreglo global para guardar posiciones de los árboles ---
const treePositions = [];
  
// --- Árboles deformes y asimétricos ---
function createDeformedTree(x,z){
  const scale = Math.random()*1.5+0.5;
  const segments = 6 + Math.floor(Math.random()*6);
  const trunkGeo = new THREE.CylinderGeometry(
    0.05*scale, 0.3*scale, 2.2*scale, segments, 1
  );
  trunkGeo.vertices?.forEach(v=>{
    v.x += (Math.random()-0.5)*0.3;
    v.z += (Math.random()-0.5)*0.3;
  });
  const trunkMat = new THREE.MeshStandardMaterial({
    color:0x002a00,
    wireframe:Math.random()<0.3
  });
  const trunk = new THREE.Mesh(trunkGeo,trunkMat);
  trunk.position.set(x,scale,z);
  trunk.rotation.y = Math.random()*Math.PI*2;
  scene.add(trunk);

  const crownGeo = new THREE.DodecahedronGeometry(1.2*scale,0);
  const crownMat = new THREE.MeshStandardMaterial({
    color:0x0a5e05,
    wireframe:Math.random()<0.2
  });
  const crown = new THREE.Mesh(crownGeo,crownMat);
  crown.position.set(x,2.4*scale,z);
  crown.scale.set(Math.random()*1.3+0.7, Math.random()*1.8+0.4, Math.random()*1.3+0.7);
  scene.add(crown);
    // ✅ Guarda posición para las conexiones subterráneas
  treePositions.push({ x, z });

}

// --- Capa densa de árboles deformes ---
for(let i=0;i<400;i++){
  const x = Math.random()*600 -300;
  const z = Math.random()*600 -300;
  createDeformedTree(x,z);
}

// --- Capa espesa de árboles vectoriales abstractos ---
for(let i=0;i<250;i++){
  const shape = new THREE.Shape();
  let x = 0, y = 0;
  shape.moveTo(x,y);
  for(let j=0;j<5+Math.random()*10;j++){
    x += (Math.random()-0.5)*2;
    y += (Math.random()*2);
    shape.lineTo(x,y);
  }
  const geo = new THREE.ShapeGeometry(shape);
  const mat = new THREE.MeshBasicMaterial({
    color: new THREE.Color(`hsl(${Math.random()*120}, 50%, 30%)`),
    wireframe:true
  });
  const mesh = new THREE.Mesh(geo,mat);
  mesh.position.set(Math.random()*600-300, 0, Math.random()*600-300);
  mesh.rotation.y = Math.random()*Math.PI*2;
  mesh.scale.setScalar(Math.random()*3+1);
  scene.add(mesh);
}

// --- Árboles extremadamente altos ---
for(let i=0;i<60;i++){
  const x = Math.random()*600 -300;
  const z = Math.random()*600 -300;
  const height = Math.random()*50 + 20;
  const trunkGeo = new THREE.CylinderGeometry(0.3, 1.5, height, 12);
  const trunkMat = new THREE.MeshStandardMaterial({
    color: 0x001800,
    wireframe: Math.random()<0.3
  });
  const trunk = new THREE.Mesh(trunkGeo, trunkMat);
  trunk.position.set(x, height/2, z);
  scene.add(trunk);
}

// --- Suelo puntillista ---
const pointCount = 6000;
const pointsGeo = new THREE.BufferGeometry();
const positions = [];
const colors = [];
for(let i=0;i<pointCount;i++){
  positions.push(Math.random()*600-300, 0, Math.random()*600-300);
  const green = 0.1 + Math.random()*0.6;
  colors.push(0, green, 0);
}
pointsGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
pointsGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors,3));
const pointsMat = new THREE.PointsMaterial({vertexColors:true, size:0.25});
scene.add(new THREE.Points(pointsGeo, pointsMat));

// --- Audio ---
function makeTextSprite(message){
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.font = "12px Arial";
  const w = ctx.measureText(message).width + 10;
  const h = 18;
  canvas.width = w; canvas.height = h;
  ctx.font = "12px Arial";
  ctx.fillStyle = "white";
  ctx.fillText(message, 0, 12);
  const texture = new THREE.CanvasTexture(canvas);
  const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map:texture}));
  sprite.scale.set(w*0.02, h*0.02,1);
  return sprite;
}

const audioData = [
  {url:'https://dn721609.ca.archive.org/0/items/festival-la-ilusion-2023/La%20Ilusio%CC%81n%20Festival%20-%20Bosque%20Cautivo%20-%20Ivonne%20Vazquez%20Portilla.wav', label:'Bosque Cautivo - Ivonne Vazquez Portilla', pos:[0,1,0], color:0xff5555},
  {url:'https://dn721609.ca.archive.org/0/items/festival-la-ilusion-2023/La%20Ilusio%CC%81n%20Festival%20-%20C001%20-%20Eliz%20Go%CC%81mez%20_Bioluminik_%20%28Obra%20sonora%29.wav', label:'C001 - Eliz Gómez - _Bioluminik_', pos:[50,1,50], color:0x55ff55},
  {url:'https://dn721609.ca.archive.org/0/items/festival-la-ilusion-2023/La%20Ilusio%CC%81n%20Festival%20-%20Cuando%20suene%20el%20u%CC%81ltimo%20grillo%20-%20Fernando%20Feria%20_%20Irizaida%20Navar%20%28Obra%20sonora%29.wav', label:'El último grillo - Fernando Feria | Irizaida Navar', pos:[-50,1,50], color:0x5555ff},
  {url:'https://dn721609.ca.archive.org/0/items/festival-la-ilusion-2023/La%20Ilusio%CC%81n%20Festival%20-%20Devenir%20poemas%20-%20Cecilia%20Morales%20%28Obra%20sonora%29.wav', label:'Devenir poemas - Cecilia Morales', pos:[-60,1,-60], color:0xffff55},
  {url:'https://dn721609.ca.archive.org/0/items/festival-la-ilusion-2023/La%20Ilusio%CC%81n%20Festival%20-%20EcoEscucha%20-%20Zael%20Ortega%20%28Obra%20sonora%29.wav', label:'EcoEscucha - Zael Ortega', pos:[60,1,-60], color:0xff55ff},
  {url:'https://dn721609.ca.archive.org/0/items/festival-la-ilusion-2023/La%20Ilusio%CC%81n%20Festival%20-%20El%20ritmo%20es%20el%20agua%20de%20las%20gotas%20que%20caen%20cuando%20lloras%20-%20He%CC%81ctor%20Ulises%20Vera%20%28Obra%20sonora%29%20wav.wav', label:'El ritmo es el agua de las gotas cuando lloras - Hector Ulises Vera', pos:[0,1,70], color:0x55ffff},
  {url:'https://dn721609.ca.archive.org/0/items/festival-la-ilusion-2023/La%20Ilusio%CC%81n%20Festival%20-%20Eucalyptus%20-%20Nicolas%20Vazquez.wav', label:'Eucalyptus - Nicolas Vasquez', pos:[80,1,0], color:0xffffff},
  {url:'https://dn721609.ca.archive.org/0/items/festival-la-ilusion-2023/La%20Ilusio%CC%81n%20Festival%20-%20Grindelia%20Buphtalmoides%20-%20Rodrigo%20Tamay%20.wav', label:'Grindelia Buphtalmoides - Rodrigo Tamay', pos:[-80,1,0], color:0xffaa55},
  {url:'https://dn721609.ca.archive.org/0/items/festival-la-ilusion-2023/La%20Ilusio%CC%81n%20Festival%20-%20Lluvia%2C%20ri%CC%81o%2C%20humedal%20-%20Marina%20Carrasco%20%28Radio%29.wav', label:'Lluvia, río, humedal - Marina Carrasco', pos:[0,1,-80], color:0xaa55ff},
  {url:'https://dn721609.ca.archive.org/0/items/festival-la-ilusion-2023/La%20Ilusio%CC%81n%20Festival%20-%20Ralu%CC%81n%20-%20Francisco%20Fuenzalida.wav', label:'Ralún - Francisco Fuen Salida', pos:[20,1,-100], color:0xffffff},
];

// --- Textos ocultos entre los árboles ---
const hiddenTextMessages = [
  "El mundo siempre es nuevo... Por muy viejas que sean sus raíces. — Ursula K. Le Guin",
  "Como un tejido, para restaurar un bosque primero debemos entender de qué está hecho. — Humberto Cumbalaza",
  "El florecimiento será cultivado como una respons|habilidad multiespecies. — Donna J. Haraway",
  "Construir relaciones simbióticas significa aprender a prestar atención. — Helen Torres"
];

// Crear sprites de texto escondidos
const hiddenTexts = hiddenTextMessages.map((msg, i) => {
  const pos = new THREE.Vector3(
    (Math.random() - 0.5) * 300, // dispersión aleatoria
    0,
    (Math.random() - 0.5) * 300
  );
  return createHiddenText(msg, pos);
});

// Conectar los textos ocultos con árboles al azar mediante líneas subterráneas
hiddenTexts.forEach(textSprite => {
  const randomTree = treePositions[Math.floor(Math.random() * treePositions.length)];
 connectUndergroundText(
  new THREE.Vector3(randomTree.x, 0, randomTree.z),
  textSprite.position
);
});

function createHiddenText(message, position) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const fontSize = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent) ? 32 : 18;
  ctx.font = `${fontSize}px monospace`;
  const w = ctx.measureText(message).width + 40;
  const h = fontSize + 10;
  canvas.width = w;
  canvas.height = h;

  ctx.font = `${fontSize}px monospace`;
  ctx.fillStyle = "rgba(200, 200, 200, 0.9)"; // más visible
  ctx.strokeStyle = "rgba(0,0,0,0.5)";
  ctx.lineWidth = 3;
  ctx.strokeText(message, 0, fontSize);
  ctx.fillText(message, 0, fontSize);

  const texture = new THREE.CanvasTexture(canvas);
  const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, transparent: true }));
  sprite.scale.set(w * 0.02, h * 0.02, 1);
  sprite.position.set(position.x, position.y + 1.5, position.z); // más alto
  scene.add(sprite);
  return sprite;
}

  // ------

  
function initAudio(){
  const listener = new THREE.AudioListener();
  camera.add(listener);
  const humanTrees = [];


  audioData.forEach((item, index) => {
    const darkColor = new THREE.Color(item.color).multiplyScalar(0.4);
    const group = new THREE.Group();

    // Elegir aleatoriamente un "tipo" de árbol humano
    const type = index % 4; // 4 variaciones

    // --- Tronco / cuerpo principal ---
    const height = 1.8 + Math.random() * 1.2;
    const bodyGeo = new THREE.CylinderGeometry(
      0.1 + Math.random()*0.1,
      0.2 + Math.random()*0.15,
      height,
      6 + Math.floor(Math.random()*4)
    );
    const bodyMat = new THREE.MeshBasicMaterial({color: darkColor, wireframe:true});
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = height/2;
    group.add(body);

    // --- Cabeza fractal (ramas desordenadas o estructuras caóticas) ---
    const headGroup = new THREE.Group();
    const headTypes = 6 + Math.floor(Math.random()*10);
    for (let i = 0; i < headTypes; i++) {
      const length = Math.random()*2 + 0.5;
      const thickness = 0.02 + Math.random()*0.05;
      const branchGeo = new THREE.CylinderGeometry(thickness/2, thickness, length, 5);
      const branchMat = new THREE.MeshBasicMaterial({color: darkColor, wireframe:true});
      const branch = new THREE.Mesh(branchGeo, branchMat);
      branch.position.y = height + Math.random()*0.5;
      branch.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
      headGroup.add(branch);
    }
    group.add(headGroup);

    // --- Brazos tipo ramas ---
    const armCount = 2 + Math.floor(Math.random()*3); // algunos con 2, otros con más
    for (let i = 0; i < armCount; i++) {
      const armGeo = new THREE.CylinderGeometry(0.03, 0.06, 1.2 + Math.random()*0.5, 6);
      const armMat = new THREE.MeshBasicMaterial({color: darkColor, wireframe:true});
      const arm = new THREE.Mesh(armGeo, armMat);
      arm.position.y = height * 0.7 + Math.random()*0.2;
      arm.position.x = (i % 2 === 0 ? -0.5 : 0.5) + (Math.random() - 0.5) * 0.2;
      arm.rotation.z = (i % 2 === 0 ? Math.PI / 3 : -Math.PI / 3) + (Math.random()-0.5)*0.3;

      // Dedos irregulares
      const fingerCount = 2 + Math.floor(Math.random()*3);
      for (let j = 0; j < fingerCount; j++) {
        const fingerGeo = new THREE.CylinderGeometry(0.005, 0.02, 0.4 + Math.random()*0.3, 4);
        const fingerMat = new THREE.MeshBasicMaterial({color: darkColor, wireframe:true});
        const finger = new THREE.Mesh(fingerGeo, fingerMat);
        finger.position.y = 0.6;
        finger.position.x = (j - 1) * 0.1;
        finger.rotation.z = (j - 1) * 0.4;
        arm.add(finger);
      }

      group.add(arm);
    }

    // --- Raíces visibles ---
    const rootCount = 5 + Math.floor(Math.random()*5);
    for (let r = 0; r < rootCount; r++) {
      const rootGeo = new THREE.CylinderGeometry(0.01, 0.05, Math.random()*2 + 0.5, 4);
      const rootMat = new THREE.MeshBasicMaterial({color: darkColor, wireframe:true});
      const root = new THREE.Mesh(rootGeo, rootMat);
      root.position.y = -0.5;
      root.position.x = Math.sin(r * Math.PI / 3) * 0.5;
      root.position.z = Math.cos(r * Math.PI / 3) * 0.5;
      root.rotation.x = Math.random() * 0.6 + 0.2;
      root.rotation.z = (Math.random() - 0.5) * 1.2;
      group.add(root);
    }

    // --- Variaciones fractales adicionales según tipo ---
    if (type === 1) {
      // Árbol con ramificaciones laterales múltiples
      for (let i = 0; i < 6; i++) {
        const branchGeo = new THREE.CylinderGeometry(0.02, 0.05, 1.5 + Math.random(), 5);
        const branch = new THREE.Mesh(branchGeo, bodyMat);
        branch.position.y = 1 + Math.random();
        branch.rotation.z = (Math.random()-0.5) * 1.5;
        branch.rotation.x = (Math.random()-0.5) * 1.5;
        group.add(branch);
      }
    } else if (type === 2) {
      // Árbol en espiral
      for (let i = 0; i < 12; i++) {
        const ringGeo = new THREE.TorusGeometry(0.2 + i*0.05, 0.01, 3, 12);
        const ringMat = new THREE.MeshBasicMaterial({color: darkColor, wireframe:true});
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = Math.PI/2;
        ring.position.y = i*0.2;
        group.add(ring);
      }
    } else if (type === 3) {
      // Árbol nervioso con líneas fractales
      const lines = new THREE.Group();
      for (let l = 0; l < 40; l++) {
        const material = new THREE.LineBasicMaterial({color: darkColor});
        const points = [];
        let x = 0, y = 0, z = 0;
        for (let k = 0; k < 6; k++) {
          x += (Math.random() - 0.5) * 0.3;
          y += 0.3;
          z += (Math.random() - 0.5) * 0.3;
          points.push(new THREE.Vector3(x, y, z));
        }
        const geo = new THREE.BufferGeometry().setFromPoints(points);
        lines.add(new THREE.Line(geo, material));
      }
      group.add(lines);
    }

    // Posición general
    group.position.set(...item.pos);
    scene.add(group);

    // --- Audio posicional ---
    const sound = new THREE.PositionalAudio(listener);
    const audioLoader = new THREE.AudioLoader();
    audioLoader.load(item.url, buffer=>{
      sound.setBuffer(buffer);
      sound.setRefDistance(12);
      sound.setLoop(true);
      sound.setVolume(0.5);
      sound.play();
    });
    group.add(sound);
    humanTrees.push(group);


    // --- Texto ---
    const sprite = makeTextSprite(item.label, {fontsize:12, textColor:"white"});
    sprite.position.set(item.pos[0], item.pos[1] + height + 1.5, item.pos[2]);
    scene.add(sprite);

    // --- Línea desde el cielo ---
    const material = new THREE.LineBasicMaterial({color: darkColor});
    const points = [
      new THREE.Vector3(item.pos[0], 100, item.pos[2]),
      new THREE.Vector3(item.pos[0], item.pos[1], item.pos[2])
    ];
    const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), material);
    scene.add(line);
  });

  connectUnderground(humanTrees, 40); // 40 conexiones subterráneas

}

// --- Conexiones subterráneas entre árboles humanos ---
function connectUnderground(elements, count = 20) { // menos líneas
  for (let i = 0; i < count; i++) {
    const a = elements[Math.floor(Math.random() * elements.length)];
    const b = elements[Math.floor(Math.random() * elements.length)];
    if (a === b) continue;

    const depth = -0.5 - Math.random() * 1.5;

    // Crear puntos de curva suave
    const points = [
      new THREE.Vector3(a.position.x, depth, a.position.z),
      new THREE.Vector3(
        (a.position.x + b.position.x) / 2 + (Math.random() - 0.5) * 2,
        depth - Math.random() * 1,
        (a.position.z + b.position.z) / 2 + (Math.random() - 0.5) * 2
      ),
      new THREE.Vector3(b.position.x, depth, b.position.z)
    ];

    // Curva tipo Catmull-Rom
    const curve = new THREE.CatmullRomCurve3(points);
    const geometry = new THREE.BufferGeometry().setFromPoints(curve.getPoints(20));

    // Material oscuro y delgado
    const colors = [0x112211, 0x223322, 0x334433];
    const material = new THREE.LineBasicMaterial({
      color: colors[Math.floor(Math.random() * colors.length)],
      transparent: false,
    });

    const line = new THREE.Line(geometry, material);
    scene.add(line);
  }
}

// --- Conexiones subterráneas entre árboles y textos ocultos ---
function connectUndergroundText(from, to) {
  const depth = -0.5 - Math.random() * 1.5;
  const points = [
    new THREE.Vector3(from.x, depth, from.z),
    new THREE.Vector3(
      (from.x + to.x) / 2 + (Math.random() - 0.5) * 2,
      depth - Math.random(),
      (from.z + to.z) / 2 + (Math.random() - 0.5) * 2
    ),
    new THREE.Vector3(to.x, depth, to.z)
  ];

  const curve = new THREE.CatmullRomCurve3(points);
  const geometry = new THREE.BufferGeometry().setFromPoints(curve.getPoints(20));
  const material = new THREE.LineBasicMaterial({
    color: 0x223322,
    transparent: false
  });

  const line = new THREE.Line(geometry, material);
  scene.add(line);
}

// --- Colocar los textos ocultos entre los árboles ---
const hiddenSprites = [];
for(let i=0; i<hiddenTexts.length; i++){
  const x = Math.random()*600 - 300;
  const z = Math.random()*600 - 300;
  const y = 0.5 + Math.random()*2; // altura del tronco/copa
  hiddenSprites.push(createHiddenText(hiddenTexts[i], {x, y, z}));
}



// --- Controles y animación ---
const controls = new PointerLockControls(camera, renderer.domElement);
camera.position.y = 1.6;
let prevTime = performance.now();
function animate(){
  requestAnimationFrame(animate);
  const time = performance.now();
  const delta = (time-prevTime)/1000;
  prevTime = time;
  controls.update(delta);
  elapsedTime += delta;
const lostArea = Math.floor(lossRate * elapsedTime);
forestLossDiv.textContent = `Bosque perdido en Colombia mientras estás aquí: ${lostArea.toLocaleString()} m²`;
  renderer.render(scene,camera);
}

// --- Resize ---
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

// --- Joysticks móviles ---
let joystickLeft = { x:0, y:0 };
let joystickRight = { x:0, y:0 };

function createJoystick(left, bottom, joystick) {
  const joy = document.createElement('div');
  joy.classList.add('joystick');
  joy.style.left = left;
  joy.style.bottom = bottom;

  const inner = document.createElement('div');
  inner.classList.add('joystick-inner');
  joy.appendChild(inner);

  document.body.appendChild(joy);

  let active = false;
  let origin = { x:0, y:0 };

  joy.addEventListener('pointerdown', e => {
    active = true;
    origin.x = e.clientX;
    origin.y = e.clientY;
  });

  joy.addEventListener('pointermove', e => {
    if(!active) return;
    joystick.x = (e.clientX - origin.x)/50;
    joystick.y = (e.clientY - origin.y)/50;
    joystick.x = Math.max(-1, Math.min(1, joystick.x));
    joystick.y = Math.max(-1, Math.min(1, joystick.y));

    inner.style.transform = `translate(${joystick.x*40}px, ${joystick.y*40}px)`;
  });

  joy.addEventListener('pointerup', ()=> {
    active = false;
    joystick.x=0; joystick.y=0;
    inner.style.transform = `translate(0,0)`;
  });
  joy.addEventListener('pointercancel', ()=> {
    active = false;
    joystick.x=0; joystick.y=0;
    inner.style.transform = `translate(0,0)`;
  });
}



function requestFullscreen(){
  const el = document.documentElement;
  if(el.requestFullscreen) el.requestFullscreen();
  else if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
  else if(el.msRequestFullscreen) el.msRequestFullscreen();
}

// Detectar cambios de orientación mientras está abierta la experiencia
window.addEventListener('resize', checkOrientation);
window.addEventListener('orientationchange', checkOrientation);

// --- Verificar orientación en móviles ---
function checkOrientation(){
  const rotateOverlay = document.getElementById('rotateOverlay');
  const isMobile = /Mobi|Android/i.test(navigator.userAgent); // Solo móviles
  if(!isMobile){
    rotateOverlay.style.display = 'none';
    return true;
  }
  if(window.innerHeight > window.innerWidth){
    rotateOverlay.style.display = 'flex'; // Mostrar aviso si vertical
    return false;
  } else {
    rotateOverlay.style.display = 'none';
    return true;
  }
}

window.addEventListener('resize', checkOrientation);
window.addEventListener('load', checkOrientation);
  
// --- Iniciar experiencia ---
document.getElementById('enterBtn').addEventListener('click', () => {
  if(!checkOrientation()) return; // No iniciar si vertical
  requestFullscreen(); // Pedir pantalla completa

  const overlay = document.getElementById('overlay');
  overlay.style.display = 'none';

  const isMobile = /Mobi|Android/i.test(navigator.userAgent);
  initAudio(); 

  if(isMobile){
    // Posición inicial
    camera.position.set(0, 1.6, 10);
    camera.lookAt(0, 1.6, 0);

    // Crear joysticks
createJoystick('30px','30px', joystickLeft); // izquierdo abajo
createJoystick('calc(100% - 150px)','30px', joystickRight); // derecho abajo

    function animateMobileFPS(){
      requestAnimationFrame(animateMobileFPS);
      const delta = 0.016;
      const velocity = new THREE.Vector3();
      velocity.z = -joystickLeft.y * 5 * delta;
      velocity.x = joystickLeft.x * 5 * delta;
      const direction = new THREE.Vector3();
      direction.copy(velocity).applyQuaternion(camera.quaternion);
      camera.position.add(direction);
      const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
      euler.y -= joystickRight.x * 2 * delta;
      euler.x -= joystickRight.y * 1.5 * delta;
      euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
      camera.quaternion.setFromEuler(euler);
      elapsedTime += delta;
const lostArea = Math.floor(lossRate * elapsedTime);
forestLossDiv.textContent = `Bosque perdido en Colombia mientras estás aquí:${lostArea.toLocaleString()} m²`;
      renderer.render(scene, camera);
    }
    animateMobileFPS();
  } else {
    controls.lock();
    animate();
  }
});
  
</script>



<style>
/* --- Estilos para los controles táctiles --- */
  
#touchControls {
  position: fixed;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 9999;
  display: none;
  flex-direction: column;
  align-items: center;
  gap: 10px;
}

#touchControls button {
  background: rgba(255,255,255,0.2);
  border: 1px solid rgba(255,255,255,0.4);
  color: white;
  font-size: 18px;
  padding: 8px 14px;
  border-radius: 10px;
  backdrop-filter: blur(4px);
  user-select: none;
}

#middleButtons {
  display: flex;
  gap: 16px;
}

/* Botón "Centrar vista" un poco más pequeño */
#btnCenter {
  font-size: 16px;
  padding: 6px 12px;
  margin-top: 6px;
  opacity: 0.8;
}

/* Mostrar solo en pantallas pequeñas */
@media (max-width: 768px) {
 #touchControls {
  display: flex;
}
}

</style>

  
</body>
</html>
